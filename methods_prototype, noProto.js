// Свойство __proto__ считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.

// Современные же методы это:

// Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
// Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
// Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
// Эти методы нужно использовать вместо __proto__.

// Например:

// let animal = {
//   eats: true
// };

// // создаём новый объект с прототипом animal
// let rabbit = Object.create(animal);

// alert(rabbit.eats); // true

// alert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit

// Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}
// У Object.create есть необязательный второй аргумент: дескрипторы свойств. Мы можем добавить дополнительное свойство новому объекту таким образом:

// let animal = {
//   eats: true
// };

// let rabbit = Object.create(animal, {
//   jumps: {
//     value: true
//   }
// });

// alert(rabbit.jumps); // true
// Формат задания дескрипторов описан в главе Флаги и дескрипторы свойств.

// Мы также можем использовать Object.create для «продвинутого» клонирования объекта, более мощного, чем копирование свойств в цикле for..in:

// клон obj c тем же прототипом (с поверхностным копированием свойств)
// let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
// Такой вызов создаёт точную копию объекта obj, включая все свойства: перечисляемые и неперечисляемые, геттеры/сеттеры для свойств – и всё это с правильным свойством [[Prototype]].

// Как мы знаем, объекты можно использовать как ассоциативные массивы для хранения пар ключ/значение.

// …Но если мы попробуем хранить созданные пользователями ключи (например, словари с пользовательским вводом), мы можем заметить интересный сбой: все ключи работают как ожидается, за исключением "__proto__".

// Посмотрите на пример:

// let obj = {};

// let key = prompt("What's the key?", "__proto__");
// obj[key] = "some value";

// alert(obj[key]); // [object Object], не "some value"!

// Если пользователь введёт __proto__, присвоение проигнорируется!

// И это не должно удивлять нас. Свойство __proto__ особенное: оно должно быть либо объектом, либо null, а строка не может стать прототипом.

// Но мы не намеревались реализовывать такое поведение, не так ли? Мы хотим хранить пары ключ/значение, и ключ с именем "__proto__" не был сохранён надлежащим образом. Так что это ошибка!

// Так что при чтении или установке obj.__proto__ вызывается соответствующий геттер/сеттер из прототипа obj, и именно он устанавливает/получает свойство [[Prototype]].

// Как было сказано в начале этой секции учебника, __proto__ – это способ доступа к свойству [[Prototype]], это не само свойство [[Prototype]].

// Теперь, если мы хотим использовать объект как ассоциативный массив, мы можем сделать это с помощью небольшого трюка:

// let obj = Object.create(null);

// let key = prompt("What's the key?", "__proto__");
// obj[key] = "some value";

// alert(obj[key]); // "some value"
// Object.create(null) создаёт пустой объект без прототипа ([[Prototype]] будет null):

// Таким образом не будет унаследованного геттера/сеттера для __proto__. Теперь это свойство обрабатывается как обычное свойство, и приведённый выше пример работает правильно.

// Мы можем назвать такой объект «простейшим» или «чистым словарным объектом», потому что он ещё проще, чем обычные объекты {...}.

// Недостаток в том, что у таких объектов не будет встроенных методов объекта, таких как toString:

// let obj = Object.create(null);

// alert(obj); // Ошибка (no toString)
// …Но обычно это нормально для ассоциативных массивов.

// Обратите внимание, что большая часть методов, связанных с объектами, имеют вид Object.something(...). К примеру, Object.keys(obj). Подобные методы не находятся в прототипе, так что они продолжат работать для таких объектов:

// let chineseDictionary = Object.create(null);
// chineseDictionary.hello = "你好";
// chineseDictionary.bye = "再见";

// alert(Object.keys(chineseDictionary)); // hello,bye