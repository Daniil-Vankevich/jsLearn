// Пример без ошибок: выведет alert (1) и (2):

// try {

//   alert('Начало блока try');  // (1) <--

//   // ...код без ошибок

//   alert('Конец блока try');   // (2) <--

// } catch(err) {

//   alert('Catch игнорируется, так как нет ошибок'); // (3)

// }

// .............................................

// пример с ошибками: выведет (1) и (3)

// try {
// 	alert('Начало блока try');

// 	lalala; //ошибка, переменная не определена!
// } catch(err) {

// 	alert('Возникла ошибка!');
// }

// try..catch работает только для ошибок, возникающих во время выполнения кода.......................try..catch работает синхронно:

// Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает:

// try {
// 	setTimeout(function() {
// 		noSuchVariable; //скрипт упадет тут
// 	}, 1000);
// } catch(error) {
// 	alert("не сработает")
// }

// Это потому, что функция выполняется позже, когда движок уже покинул конструкцию try..catch. Чтобы поймать исключение внутри запланированной функции, try..catch должен находиться внутри самой этой функции:

// setTimeout(function() {
// 	try {
// 		noSuchVariable; // try..catch обрабатывает ошибку!
// 	} catch {
// 		console.log("ошибка поймана!");
// 	}
// }, 1000);

// .....................................

// name
// Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
// message
// Текстовое сообщение о деталях ошибки.
// В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:

// stack
// Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.

// try {
//   lalala; // ошибка, переменная не определена!
// } catch(err) {
//   alert(err.name); // ReferenceError
//   alert(err.message); // lalala is not defined
//   alert(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)

//   // Можем также просто вывести ошибку целиком
//   // Ошибка приводится к строке вида "name: message"
//   alert(err); // ReferenceError: lalala is not defined 
// }

// ...............................................

// Если нам не нужны детали ошибки, в catch можно её пропустить:

// try {
//   // ...
// } catch { //  <-- без (err)
//   // ...
// }

// ......................................

// Использование «try…catch»

// let json = '{"name":"John", "age": 30}'; // данные с сервера

// let user = JSON.parse(json); // преобразовали текстовое представление в JS-объект

// // теперь user - объект со свойствами из строки
// console.log( user.name ); // John
// console.log( user.age );  // 30

// ......................................

// let json = "{ некорректный JSON }";

// try {

//   let user = JSON.parse(json); // <-- тут возникает ошибка...
//   alert( user.name ); // не сработает

// } catch (e) {
//   // ...выполнение прыгает сюда
//   alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз." );
//   alert( e.name );
//   alert( e.message ); 
// }

// Генерация собственных ошибок

// let json = '{ "age": 30 }'; // данные неполны

// try {

//   let user = JSON.parse(json); // <-- выполнится без ошибок
//   alert( user.name ); // нет свойства name!

// } catch (e) {
//   alert( "не выполнится" );
// }
// Здесь JSON.parse выполнится без ошибок, но на самом деле отсутствие свойства name для нас ошибка.

// Для того, чтобы унифицировать обработку ошибок, мы воспользуемся оператором throw.

// В нашем случае отсутствие свойства name – это ошибка, ведь пользователи должны иметь имена.


// Оператор throw генерирует ошибку.
// Сгенерируем её:

// let json = '{ "age": 30 }'; // данные неполны

// try {

//   let user = JSON.parse(json); // <-- выполнится без ошибок

//   if (!user.name) {
//     throw new SyntaxError("Данные неполны: нет имени"); // (*)
//   }

//   alert( user.name );

// } catch(e) {
//   alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени
// }

// ........................................

// В коде ниже мы используем проброс исключения, catch обрабатывает только SyntaxError:

let json = '{ "age": 30 }'; // данные неполны
try {

  let user = JSON.parse(json);

  if (!user.name) {
    throw new SyntaxError("Данные неполны: нет имени");
  }

  blabla(); // неожиданная ошибка

  console.log( user.name );

} catch(e) {

  if (e.name == "SyntaxError") {
    console.log( "JSON Error: " + e.message );
  } else {
    throw e; // проброс (*)
  }

}

// .............................................

// Пример ниже демонстрирует, как такие ошибки могут быть пойманы с помощью ещё одного уровня try..catch:

function readData() {
	let jsom = '{"age": 30}';

	try {
		//....
		blablavla() //error
	
	} catch(e) {
		//....
		if (e.name != 'SyntaxError') {
			throw e; // проброс исключения (не знаю как это обработать)
		}
	}
}

try {
	readData();
} catch (e) {
	console.log("Внешний catch поймал " + e); // поймал!
}


// .....................................

// try {
//   alert( 'try' );
//   if (confirm('Сгенерировать ошибку?')) BAD_CODE();
// } catch (e) {
//   alert( 'catch' );
// } finally {
//   alert( 'finally' );
// }


// У кода есть два пути выполнения:

// Если вы ответите на вопрос «Сгенерировать ошибку?» утвердительно, то try -> catch -> finally.
// Если ответите отрицательно, то try -> finally.
// Секцию finally часто используют, когда мы начали что-то делать и хотим завершить это вне зависимости от того, будет ошибка или нет.

// ..........................................

// Здесь finally гарантирует, что время будет измерено корректно в обеих ситуациях – и в случае успешного завершения fib и в случае ошибки:

// .........................................

